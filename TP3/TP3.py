from Crypto.Util.number import *
from gmpy2 import *

p = 857504083339712752489993810777
q = 1029224947942998075080348647219
phi = (p - 1) * (q - 1)
#print(phi)


#RSA Starter 4
e = 65537
d = inverse(e, phi) #private key
#print(d)
c = 77578995801157823671636298847186723593814843845525223303932
n = p*q

m = pow(c, d, n) #decode RSA
#print(m)


#Many prime
factors = [9282105380008121879,9303850685953812323,9389357739583927789,10336650220878499841,10638241655447339831
,11282698189561966721,11328768673634243077,11403460639036243901,11473665579512371723,11492065299277279799
,11530534813954192171,11665347949879312361,12132158321859677597,12834461276877415051,12955403765595949597
,12973972336777979701,13099895578757581201,13572286589428162097,14100640260554622013,14178869592193599187
,14278240802299816541,14523070016044624039,14963354250199553339,15364597561881860737,15669758663523555763
,15824122791679574573,15998365463074268941,16656402470578844539,16898740504023346457,17138336856793050757
,17174065872156629921,17281246625998849649]

phi = factors[0] - 1
for f in factors[1:]:
    phi *= f -1

d = inverse(e, phi) #private key
n = 580642391898843192929563856870897799650883152718761762932292482252152591279871421569162037190419036435041797739880389529593674485555792234900969402019055601781662044515999210032698275981631376651117318677368742867687180140048715627160641771118040372573575479330830092989800730105573700557717146251860588802509310534792310748898504394966263819959963273509119791037525504422606634640173277598774814099540555569257179715908642917355365791447508751401889724095964924513196281345665480688029639999472649549163147599540142367575413885729653166517595719991872223011969856259344396899748662101941230745601719730556631637
ct = 320721490534624434149993723527322977960556510750628354856260732098109692581338409999983376131354918370047625150454728718467998870322344980985635149656977787964380651868131740312053755501594999166365821315043312308622388016666802478485476059625888033017198083472976011719998333985531756978678758897472845358167730221506573817798467100023754709109274265835201757369829744113233607359526441007577850111228850004361838028842815813724076511058179239339760639518034583306154826603816927757236549096339501503316601078891287408682099750164720032975016814187899399273719181407940397071512493967454225665490162619270814464
m = pow(ct, d, n) #decode RSA
#print(m)
#print(long_to_bytes(m))

"""Buscamos los factores de la clave publica/modulo N en factorDB y multiplicamos cada uno por su anterior (factor-1) en un unico resultado
, hacemos la multiplicacion inversa de este resultado por el exponente E dandonos la key privada D.
Luego para desenctriptar el mensaje numerico, elevamos el mismo a la potencia de key privada D en el modulo N(key publica).
El resultado es numerico, para obtener el flag debemos pasarlo su representacion en bytes char
FLAG=crypto{700_m4ny_5m4ll_f4c70r5}"""

#Salty
e = 1
n = 110581795715958566206600392161360212579669637391437097703685154237017351570464767725324182051199901920318211290404777259728923614917211291562555864753005179326101890427669819834642007924406862482343614488768256951616086287044725034412802176312273081322195866046098595306261781788276570920467840172004530873767
phi = n-1
d = inverse(e, phi) #private key
ct = 44981230718212183604274785925793145442655465025264554046028251311164494127485
m = pow(ct, d, n) #decode RSA
#print(m)
#print(long_to_bytes(m))


"""Al intentar factorizar la clave publica N, encontramos que este es un numero primo, por lo que su Phi es N-1.
Obtenemos la key privada D haciendo la multiplicacion inversa entre E y Phi o N-1.
Luego para desenctriptar el mensaje numerico, elevamos este a la potencia D en el modulo N.
El resultado es numerico, para obtener el flag debemos pasarlo su representacion en bytes char.
Parece ser una vulnerabilidad muy grande que la clave publica no este compuesta por numeros coprimos
FLAG=crypto{saltstack_fell_for_this!}"""

#Modulus Inutilis
from Crypto.Util.number import long_to_bytes, inverse
e = 3
n = 17258212916191948536348548470938004244269544560039009244721959293554822498047075403658429865201816363311805874117705688359853941515579440852166618074161313773416434156467811969628473425365608002907061241714688204565170146117869742910273064909154666642642308154422770994836108669814632309362483307560217924183202838588431342622551598499747369771295105890359290073146330677383341121242366368309126850094371525078749496850520075015636716490087482193603562501577348571256210991732071282478547626856068209192987351212490642903450263288650415552403935705444809043563866466823492258216747445926536608548665086042098252335883
ct = 243251053617903760309941844835411292373350655973075480264001352919865180151222189820473358411037759381328642957324889519192337152355302808400638052620580409813222660643570085177957

"""Ya que el exponente es 3 y su multiplicacion inversa , o sea, el phi nos da 1
entonces la operacion inversa es una raiz cubica.
Investigando se descubre que cada byte contiene un padding,
por lo que es necesario aumentar la precision aritmetica leyendo mas bits por cada char
FLAG=crypto{N33d_m04R_p4dd1ng}"""
ctx = get_context()

for(i)
ctx.precision = 3000
m = cbrt(ct)
print(long_to_bytes(m))
"""FLAG=crypto{N33d_m04R_p4dd1ng}"""